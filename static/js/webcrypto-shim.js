/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/webcrypto-liner@1.0.1/build/webcrypto-liner.shim.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var liner=function(e){"use strict";function t(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function r(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{},s=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(s=s.concat(Object.getOwnPropertySymbols(n).filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),s.forEach(function(r){t(e,r,n[r])})}return e}class n{static get enabled(){return"undefined"!=typeof self&&self.PV_WEBCRYPTO_LINER_LOG}static log(e,...t){this.enabled&&console.log.apply(console,arguments)}static error(e,...t){this.enabled&&console.error.apply(console,arguments)}static info(e,...t){this.enabled&&console.info.apply(console,arguments)}static warn(e,...t){this.enabled&&console.warn.apply(console,arguments)}static trace(e,...t){this.enabled&&console.trace.apply(console,arguments)}}let s;if("undefined"==typeof self){const e=require("crypto");s={crypto:{subtle:{},getRandomValues:t=>{const r=t.buffer,n=new Uint8Array(r);return e.randomBytes(n.length).forEach((e,t)=>n[t]=e),t}}}}else s=self;const i=s.msCrypto||s.crypto||{};let o=null;try{o=i.subtle||i.webkitSubtle}catch(e){console.warn("Cannot get subtle from crypto",e)}function a(e,t,r,n){var s,i=arguments.length,o=i<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,n);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i<3?s(o):i>3?s(t,r,o):s(t,r))||o);return i>3&&o&&Object.defineProperty(t,r,o),o}function c(e,t,r,n){return new(r||(r=Promise))(function(s,i){function o(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){e.done?s(e.value):new r(function(t){t(e.value)}).then(o,a)}c((n=n.apply(e,t||[])).next())})}function l(e){return"undefined"!=typeof Buffer?new Uint8Array(e):new Uint8Array(e instanceof ArrayBuffer?e:e.buffer)}class h{static ToString(e,t="utf8"){const r=l(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=l(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return Buffer.from(t).toString("base64")}static FromBase64(e){return e=e.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static ToUtf8String(e){const t=l(e),r=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(r))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToBinary(e){const t=l(e);let r="";const n=t.length;for(let e=0;e<n;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=l(e),r=[],n=t.length;for(let e=0;e<n;e++){const n=t[e].toString(16);r.push(1===n.length?"0"+n:n)}return r.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const n=e.slice(r,r+2);t[r/2]=parseInt(n,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}}class u extends Error{}class f extends u{}class y extends u{constructor(e){super(`Unsupported operation: ${e?`${e}`:""}`)}}class p extends u{}class g extends u{constructor(e){super(`${e}: Missing required property`)}}class m{static toArrayBuffer(e){if(e instanceof ArrayBuffer)return e;if("undefined"!=typeof Buffer&&Buffer.isBuffer(e))return new Uint8Array(e);if(ArrayBuffer.isView(e))return e.buffer;throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static toUint8Array(e){return new Uint8Array(this.toArrayBuffer(e))}static isBufferSource(e){return ArrayBuffer.isView(e)||e instanceof ArrayBuffer}}function d(e){return"object"==typeof e&&"kty"in e}class v{digest(e,t){return c(this,arguments,void 0,function*(){return this.checkDigest.apply(this,arguments),this.onDigest.apply(this,arguments)})}checkDigest(e,t){this.checkAlgorithmName(e)}onDigest(e,t){return c(this,void 0,void 0,function*(){throw new y("digest")})}generateKey(e,t,r){return c(this,arguments,void 0,function*(){return this.checkGenerateKey.apply(this,arguments),this.onGenerateKey.apply(this,arguments)})}checkGenerateKey(e,t,r){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let n;n=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,n)}checkGenerateKeyParams(e){}onGenerateKey(e,t,r){return c(this,void 0,void 0,function*(){throw new y("generateKey")})}sign(e,t,r){return c(this,arguments,void 0,function*(){return this.checkSign.apply(this,arguments),this.onSign.apply(this,arguments)})}checkSign(e,t,r){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}onSign(e,t,r){return c(this,void 0,void 0,function*(){throw new y("sign")})}verify(e,t,r,n){return c(this,arguments,void 0,function*(){return this.checkVerify.apply(this,arguments),this.onVerify.apply(this,arguments)})}checkVerify(e,t,r,n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}onVerify(e,t,r,n){return c(this,void 0,void 0,function*(){throw new y("verify")})}encrypt(e,t,r,n){return c(this,arguments,void 0,function*(){return this.checkEncrypt.apply(this,arguments),this.onEncrypt.apply(this,arguments)})}checkEncrypt(e,t,r,n={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"encrypt":void 0)}onEncrypt(e,t,r){return c(this,void 0,void 0,function*(){throw new y("encrypt")})}decrypt(e,t,r,n){return c(this,arguments,void 0,function*(){return this.checkDecrypt.apply(this,arguments),this.onDecrypt.apply(this,arguments)})}checkDecrypt(e,t,r,n={}){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"decrypt":void 0)}onDecrypt(e,t,r){return c(this,void 0,void 0,function*(){throw new y("decrypt")})}deriveBits(e,t,r,n){return c(this,arguments,void 0,function*(){return this.checkDeriveBits.apply(this,arguments),this.onDeriveBits.apply(this,arguments)})}checkDeriveBits(e,t,r,n={}){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,n.keyUsage?"deriveBits":void 0),r%8!=0)throw new p("length: Is not multiple of 8")}onDeriveBits(e,t,r){return c(this,void 0,void 0,function*(){throw new y("deriveBits")})}exportKey(e,t){return c(this,arguments,void 0,function*(){return this.checkExportKey.apply(this,arguments),this.onExportKey.apply(this,arguments)})}checkExportKey(e,t){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new u("key: Is not extractable")}onExportKey(e,t){return c(this,void 0,void 0,function*(){throw new y("exportKey")})}importKey(e,t,r,n,s){return c(this,arguments,void 0,function*(){return this.checkImportKey.apply(this,arguments),this.onImportKey.apply(this,arguments)})}checkImportKey(e,t,r,n,s){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(s,this.usages)}onImportKey(e,t,r,n,s){return c(this,void 0,void 0,function*(){throw new y("importKey")})}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new f("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(-1===t.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&-1===e.usages.indexOf(t))throw new u("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new g(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new p(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===e){if(!d(t))throw new TypeError("keyData: Is not JsonWebToken")}else if(!m.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrrayBuffer")}prepareData(e){return m.toArrayBuffer(e)}}class k extends v{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class w extends k{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}}class b extends k{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==e.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not a Number");if(e.length<1)throw new p("length: Must be more than 0")}}class B extends k{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class A extends k{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new p("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in e||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new p("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class S extends k{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class x extends v{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),"number"!=typeof e.length)throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new p(`algorith.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class C extends v{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=h.ToBase64(e.publicExponent);if("Aw=="!==t&&"AQAB"!==t)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class N extends C{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class E extends C{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),"number"!=typeof e.saltLength)throw new TypeError("saltLength: Is not a Number");if(e.saltLength<1)throw new RangeError("saltLength: Must be more than 0")}}class K extends C{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class U extends v{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new p(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}class O extends U{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}const L=["secret","private","public"];class P{static create(e,t,r,n){const s=new this;return s.algorithm=e,s.type=t,s.extractable=r,s.usages=n,s}static isKeyType(e){return-1!==L.indexOf(e)}}class T extends U{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof P))throw new TypeError("public: Is not a CryptoKey");if("public"!==e.public.type)throw new p("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new p(`public: Is not ${this.name} key`)}}class H extends v{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),"number"!=typeof e.iterations)throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,n,s){if(super.checkImportKey(e,t,r,n,s),n)throw new SyntaxError("extractable: Must be False")}}class I{}class R{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}class D{constructor(){this.providers=new R}static isHashedAlgorithm(e){return e instanceof Object&&"name"in e&&"hash"in e}digest(e,t){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"digest");const r=this.prepareAlgorithm(e),n=m.toArrayBuffer(t),s=this.getProvider(r.name);return yield s.digest(r,n)})}generateKey(e,t,r){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"generateKey");const n=this.prepareAlgorithm(e),s=this.getProvider(n.name);return yield s.generateKey(Object.assign({},n,{name:s.name}),t,r)})}sign(e,t,r){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"sign"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=m.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.sign(Object.assign({},n,{name:i.name}),t,s)})}verify(e,t,r,n){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,4,"verify"),this.checkCryptoKey(t);const s=this.prepareAlgorithm(e),i=m.toArrayBuffer(n),o=m.toArrayBuffer(r),a=this.getProvider(s.name);return yield a.verify(Object.assign({},s,{name:a.name}),t,o,i)})}encrypt(e,t,r){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"encrypt"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=m.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.encrypt(Object.assign({},n,{name:i.name}),t,s,{keyUsage:!0})})}decrypt(e,t,r){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"decrypt"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=m.toArrayBuffer(r),i=this.getProvider(n.name);return yield i.decrypt(Object.assign({},n,{name:i.name}),t,s,{keyUsage:!0})})}deriveBits(e,t,r){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,3,"deriveBits"),this.checkCryptoKey(t);const n=this.prepareAlgorithm(e),s=this.getProvider(n.name);return yield s.deriveBits(Object.assign({},n,{name:s.name}),t,r,{keyUsage:!0})})}deriveKey(e,t,r,n,s){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"deriveKey");const i=this.prepareAlgorithm(r);this.getProvider(i.name).checkDerivedKeyParams(i);const o=this.prepareAlgorithm(e),a=this.getProvider(o.name);a.checkCryptoKey(t,"deriveKey");const c=yield a.deriveBits(Object.assign({},o,{name:a.name}),t,r.length,{keyUsage:!1});return this.importKey("raw",c,r,n,s)})}exportKey(e,t){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,2,"exportKey"),this.checkCryptoKey(t);const r=this.getProvider(t.algorithm.name);return yield r.exportKey(e,t)})}importKey(e,t,r,n,s){return c(this,arguments,void 0,function*(){this.checkRequiredArguments(arguments,5,"importKey");const i=this.prepareAlgorithm(r),o=this.getProvider(i.name);if(-1!==["pkcs8","spki","raw"].indexOf(e)){const r=m.toArrayBuffer(t);return o.importKey(e,r,Object.assign({},i,{name:o.name}),n,s)}if(!t.kty)throw new TypeError("keyData: Is not JSON");return o.importKey(e,t,Object.assign({},i,{name:o.name}),n,s)})}wrapKey(e,t,r,n){return c(this,void 0,void 0,function*(){let s=yield this.exportKey(e,t);if("jwk"===e){const e=JSON.stringify(s);s=h.FromUtf8String(e)}const i=this.prepareAlgorithm(n),o=m.toArrayBuffer(s),a=this.getProvider(i.name);return a.encrypt(Object.assign({},i,{name:a.name}),r,o,{keyUsage:!1})})}unwrapKey(e,t,r,n,s,i,o){return c(this,void 0,void 0,function*(){const a=this.prepareAlgorithm(n),c=m.toArrayBuffer(t),l=this.getProvider(a.name);let u=yield l.decrypt(Object.assign({},a,{name:l.name}),r,c,{keyUsage:!1});if("jwk"===e)try{u=JSON.parse(h.ToUtf8String(u))}catch(e){const t=new TypeError("wrappedKey: Is not a JSON");throw t.internal=e,t}return this.importKey(e,u,s,i,o)})}checkRequiredArguments(e,t,r){if(e.length!==t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if("string"==typeof e)return{name:e};if(D.isHashedAlgorithm(e)){const t=Object.assign({},e);return t.hash=this.prepareAlgorithm(e.hash),t}return Object.assign({},e)}getProvider(e){const t=this.providers.get(e);if(!t)throw new f("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof P))throw new TypeError("Key is not of type 'CryptoKey'")}}function J(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function V(e,t){return e(t={exports:{}},t.exports),t.exports}function j(e,t){let r=0;if(1===e.length)return e[0];for(let n=e.length-1;n>=0;n--)r+=e[e.length-1-n]*Math.pow(2,t*n);return r}function M(e,t,r=-1){const n=r;let s=e,i=0,o=Math.pow(2,t);for(let r=1;r<8;r++){if(e<o){let e;if(n<0)e=new ArrayBuffer(r),i=r;else{if(n<r)return new ArrayBuffer(0);e=new ArrayBuffer(n),i=n}const o=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);o[i-e-1]=Math.floor(s/r),s-=o[i-e-1]*r}return e}o*=Math.pow(2,t)}return new ArrayBuffer(0)}const F="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";const $=Math.log(2);var G=Object.freeze({getUTCDate:function(e){return new Date(e.getTime()+6e4*e.getTimezoneOffset())},getParametersValue:function(e,t,r){return e instanceof Object==0?r:t in e?e[t]:r},bufferToHexCodes:function(e,t=0,r=e.byteLength-t,n=!1){let s="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(s+="0"),s+=e,n&&(s+=" ")}return s.trim()},checkBufferParams:function(e,t,r,n){return t instanceof ArrayBuffer==0?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):n<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-n<0&&(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))},utilFromBase:j,utilToBase:M,utilConcatBuf:function(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const t of e)s.set(new Uint8Array(t),r),r+=t.byteLength;return n},utilConcatView:function(...e){let t=0,r=0;for(const r of e)t+=r.length;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const t of e)s.set(t,r),r+=t.length;return s},utilDecodeTC:function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const n=j(r,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,j(i,8)-n},utilEncodeTC:function(e){const t=e<0?-1*e:e;let r=128;for(let n=1;n<8;n++){if(t<=r){if(e<0){const e=M(r-t,8,n);return new Uint8Array(e)[0]|=128,e}let s=M(t,8,n),i=new Uint8Array(s);if(128&i[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0},padNumber:function(e,t){const r=e.toString(10);if(t<r.length)return"";const n=t-r.length,s=new Array(n);for(let e=0;e<n;e++)s[e]="0";return s.join("").concat(r)},toBase64:function(e,t=!1,r=!1,n=!1){let s=0,i=0,o=0,a="";const c=t?_:F;if(n){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;s<e.length;){const t=e.charCodeAt(s++);s>=e.length&&(i=1);const n=e.charCodeAt(s++);s>=e.length&&(o=1);const l=e.charCodeAt(s++),h=t>>2,u=(3&t)<<4|n>>4;let f=(15&n)<<2|l>>6,y=63&l;1===i?f=y=64:1===o&&(y=64),a+=r?64===f?`${c.charAt(h)}${c.charAt(u)}`:64===y?`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}`:`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}${c.charAt(y)}`:`${c.charAt(h)}${c.charAt(u)}${c.charAt(f)}${c.charAt(y)}`}return a},fromBase64:function(e,t=!1,r=!1){const n=t?_:F;function s(e){for(let t=0;t<64;t++)if(n.charAt(t)===e)return t;return 64}function i(e){return 64===e?0:e}let o=0,a="";for(;o<e.length;){const t=s(e.charAt(o++)),r=o>=e.length?0:s(e.charAt(o++)),n=o>=e.length?0:s(e.charAt(o++)),c=o>=e.length?0:s(e.charAt(o++)),l=i(t)<<2|i(r)>>4,h=(15&i(r))<<4|i(n)>>2,u=(3&i(n))<<6|i(c);a+=String.fromCharCode(l),64!==n&&(a+=String.fromCharCode(h)),64!==c&&(a+=String.fromCharCode(u))}if(r){let e=-1;for(let t=a.length-1;t>=0;t--)if(0!==a.charCodeAt(t)){e=t;break}a=-1!==e?a.slice(0,e+1):""}return a},arrayBufferToString:function(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t},stringToArrayBuffer:function(e){const t=e.length,r=new ArrayBuffer(t),n=new Uint8Array(r);for(let r=0;r<t;r++)n[r]=e.charCodeAt(r);return r},nearestPowerOf2:function(e){const t=Math.log(e)/$,r=Math.floor(t),n=Math.round(t);return r===n?r:n},clearProps:function(e,t){for(const r of t)delete e[r]}}),z=V(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.RawData=t.Repeated=t.Any=t.Choice=t.TIME=t.Duration=t.DateTime=t.TimeOfDay=t.DATE=t.GeneralizedTime=t.UTCTime=t.CharacterString=t.GeneralString=t.VisibleString=t.GraphicString=t.IA5String=t.VideotexString=t.TeletexString=t.PrintableString=t.NumericString=t.UniversalString=t.BmpString=t.Utf8String=t.ObjectIdentifier=t.Enumerated=t.Integer=t.BitString=t.OctetString=t.Null=t.Set=t.Sequence=t.Boolean=t.EndOfContent=t.Constructed=t.Primitive=t.BaseBlock=void 0,t.fromBER=oe,t.compareSchema=ae,t.verifySchema=function(e,t){if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=oe(e);if(-1===r.offset)return{verified:!1,result:r.result};return ae(r.result,r.result,t)},t.fromJSON=function(e){};const r=[new Uint8Array([1])],n="0123456789";class s{constructor(e={}){this.blockLength=(0,G.getParametersValue)(e,"blockLength",0),this.error=(0,G.getParametersValue)(e,"error",""),this.warnings=(0,G.getParametersValue)(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,G.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const i=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=(0,G.getParametersValue)(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;return 0===new Uint8Array(e,t,r).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}});class o extends(i(s)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=(0,G.getParametersValue)(e.idBlock,"isHexOnly",!1),this.valueHex=(0,G.getParametersValue)(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,G.getParametersValue)(e.idBlock,"tagClass",-1),this.tagNumber=(0,G.getParametersValue)(e.idBlock,"tagNumber",-1),this.isConstructed=(0,G.getParametersValue)(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,n=0;switch(this.tagClass){case 1:n|=0;break;case 2:n|=64;break;case 3:n|=128;break;case 4:n|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(n|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;n|=e&=31,r[0]=n}return t}if(!1===this.isHexOnly){const s=(0,G.utilToBase)(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength;if(t=new ArrayBuffer(o+1),(r=new Uint8Array(t))[0]=31|n,!e){for(let e=0;e<o-1;e++)r[e+1]=128|i[e];r[o]=i[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|n,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const s=31&n[0];if(31!==s)this.tagNumber=s,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],++e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),n=new Uint8Array(e);for(let e=0;e<r.length;e++)n[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const s=new ArrayBuffer(e),i=new Uint8Array(s);for(let t=0;t<e;t++)i[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(i),this.blockLength<=9?this.tagNumber=(0,G.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class a extends s{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=(0,G.getParametersValue)(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,G.getParametersValue)(e.lenBlock,"longFormUsed",!1),this.length=(0,G.getParametersValue)(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const s=127&n[0];if(s>8)return this.error="Too big integer",-1;if(s+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const i=new Uint8Array(s);for(let e=0;e<s;e++)i[e]=n[e+1];return 0===i[s-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,G.utilFromBase)(i,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=s+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const n=(0,G.utilToBase)(this.length,8);if(n.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength+1),!0===e)return t;const s=new Uint8Array(n);(r=new Uint8Array(t))[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class c extends s{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class l extends s{constructor(e={},t=c){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new o(e),this.lenBlock=new a(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),n=this.valueBlock.toBER(!0);this.lenBlock.length=n.byteLength;const s=this.lenBlock.toBER(e);let i;if(t=(0,G.utilConcatBuf)(r,s),i=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length),t=(0,G.utilConcatBuf)(t,i),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=(0,G.utilConcatBuf)(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}t.BaseBlock=l;class h extends c{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,G.getParametersValue)(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(n.length);const s=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)s[e]=n[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class u extends l{constructor(e={}){super(e,h),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}t.Primitive=u;class f extends c{constructor(e={}){super(e),this.value=(0,G.getParametersValue)(e,"value",[]),this.isIndefiniteForm=(0,G.getParametersValue)(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const n=t,s=r;if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;if(0===new Uint8Array(e,t,r).length)return this.warnings.push("Zero buffer length"),t;let i=t;for(;o=this.isIndefiniteForm,a=r,(!0===o?1:a)>0;){const t=ie(e,i,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(i=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===g.blockName())break}var o,a;return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===g.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(n,n+s),i}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);t=(0,G.utilConcatBuf)(t,n)}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class y extends l{constructor(e={}){super(e,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}}t.Constructed=y;class p extends c{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class g extends l{constructor(e={}){super(e,p),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}t.EndOfContent=g;class m extends c{constructor(e={}){if(super(e),this.value=(0,G.getParametersValue)(e,"value",!1),this.isHexOnly=(0,G.getParametersValue)(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){new Uint8Array(this.valueHex)[0]=255}}fromBER(e,t,r){if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const s=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)s[e]=n[e];return 0!==G.utilDecodeTC.call(this)?this.value=!0:this.value=!1,this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class d extends l{constructor(e={}){super(e,m),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}t.Boolean=d;class v extends y{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}t.Sequence=v;class k extends y{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}t.Set=k;class w extends l{constructor(e={}){super(e,s),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}t.Null=w;class b extends(i(f)){constructor(e={}){super(e),this.isConstructed=(0,G.getParametersValue)(e,"isConstructed",!1)}fromBER(e,t,r){let n=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(n=f.prototype.fromBER.call(this,e,t,r)))return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===g.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==B.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(e,t,r),this.blockLength=r;return n}toBER(e=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class B extends l{constructor(e={}){super(e,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof B!=!1&&JSON.stringify(this)===JSON.stringify(e)}}t.OctetString=B;class A extends(i(f)){constructor(e={}){super(e),this.unusedBits=(0,G.getParametersValue)(e,"unusedBits",0),this.isConstructed=(0,G.getParametersValue)(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,r){if(0===r)return t;let n=-1;if(!0===this.isConstructed){if(-1===(n=f.prototype.fromBER.call(this,e,t,r)))return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===g.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==S.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(this.unusedBits=s[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(s.length-1);const i=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)i[e]=s[e+1];return this.blockLength=s.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),n=new Uint8Array(r);n[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)n[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class S extends l{constructor(e={}){super(e,A),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof S!=!1&&JSON.stringify(this)===JSON.stringify(e)}}t.BitString=S;class x extends(i(c)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=G.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=(0,G.utilEncodeTC)(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,n=0){const s=this.fromBER(e,t,r);if(-1===s)return s;const i=new Uint8Array(this._valueHex);if(0===i[0]&&0!=(128&i[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==n&&this._valueHex.byteLength<n){n-this._valueHex.byteLength>1&&(n=this._valueHex.byteLength+1);const e=new ArrayBuffer(n);new Uint8Array(e).set(i,n-this._valueHex.byteLength),this._valueHex=e.slice(0)}return s}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const n=super.fromBER(e,t,r);return-1===n?n:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0);const o=i.length-1;let a=s.slice(0);const c=a.length-1;let l=0;let h=0;for(let e=c<o?o:c;e>=0;e--,h++){switch(!0){case h<a.length:l=i[o-h]+a[c-h]+r[0];break;default:l=i[o-h]+r[0]}switch(r[0]=l/10,!0){case h>=i.length:i=(0,G.utilConcatView)(new Uint8Array([l%10]),i);break;default:i[o-h]=l%10}}return r[0]>0&&(i=(0,G.utilConcatView)(r,i)),i.slice(0)}function t(e){if(e>=r.length)for(let t=r.length;t<=e;t++){const e=new Uint8Array([0]);let n=r[t-1].slice(0);for(let t=n.length-1;t>=0;t--){const r=new Uint8Array([(n[t]<<1)+e[0]]);e[0]=r[0]/10,n[t]=r[0]%10}e[0]>0&&(n=(0,G.utilConcatView)(e,n)),r.push(n)}return r[e]}function s(e,t){let r=0,n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0);const o=i.length-1;let a=s.slice(0);const c=a.length-1;let l,h=0;for(let e=c;e>=0;e--,h++)switch(l=i[o-h]-a[c-h]-r,!0){case l<0:r=1,i[o-h]=l+10;break;default:r=0,i[o-h]=l}if(r>0)for(let e=o-c+1;e>=0;e--,h++){if(!((l=i[o-h]-r)<0)){r=0,i[o-h]=l;break}r=1,i[o-h]=l+10}return i.slice()}const i=8*this._valueHex.byteLength-1;let o,a=new Uint8Array(8*this._valueHex.byteLength/3),c=0;const l=new Uint8Array(this._valueHex);let h="",u=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){o=l[r];for(let r=0;r<8;r++){if(1==(1&o))switch(c){case i:a=s(t(c),a),h="-";break;default:a=e(a,t(c))}c++,o>>=1}}for(let e=0;e<a.length;e++)a[e]&&(u=!0),u&&(h+=n.charAt(a[e]));return!1===u&&(h+=n.charAt(0)),h}}class C extends l{constructor(e={}){super(e,x),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof C?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?(0,G.isEqualBuffer)(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&(0,G.isEqualBuffer)(this.valueBlock.valueHex,e)}convertToDER(){const e=new C({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new C({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}t.Integer=C;class N extends C{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}t.Enumerated=N;class E extends(i(s)){constructor(e={}){super(e),this.valueDec=(0,G.getParametersValue)(e,"valueDec",-1),this.isFirstSid=(0,G.getParametersValue)(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===(0,G.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let e=0;e<r&&(s[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const i=new ArrayBuffer(this.blockLength),o=new Uint8Array(i);for(let e=0;e<this.blockLength;e++)o[e]=s[e];return this.valueHex=i.slice(0),s=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,G.utilFromBase)(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|n[e];return r[this.blockLength-1]=n[this.blockLength-1],t}const n=(0,G.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength),!1===e){const e=new Uint8Array(n);r=new Uint8Array(t);for(let t=0;t<n.byteLength-1;t++)r[t]=128|e[t];r[n.byteLength-1]=e[n.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=(0,G.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class K extends c{constructor(e={}){super(e),this.fromString((0,G.getParametersValue)(e,"value",""))}fromBER(e,t,r){let n=t;for(;r>0;){const t=new E;if(-1===(n=t.fromBER(e,n,r)))return this.blockLength=0,this.error=t.error,n;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=(0,G.utilConcatBuf)(t,n)}return t}fromString(e){this.value=[];let t=0,r=0,n="",s=!1;do{if(n=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(n,10);if(isNaN(r))return!0;e.valueDec=r+t,s=!1}else{const e=new E;if(e.valueDec=parseInt(n,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,this.value[r].isFirstSid?e=`2.{${n} - 80}`:e+=n):e+=n}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class U extends l{constructor(e={}){super(e,K),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}t.ObjectIdentifier=U;class O extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class L extends l{constructor(e={}){super(e,O),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const n=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)n[e]=t.charCodeAt(e);this.valueBlock.value=e}}t.Utf8String=L;class P extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class T extends l{constructor(e={}){super(e,P),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,G.utilToBase)(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>2)continue;const i=2-s.length;for(let e=s.length-1;e>=0;e--)r[2*n+e+i]=s[e]}this.valueBlock.value=e}}t.BmpString=T;class H extends(i(s)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class I extends l{constructor(e={}){super(e,H),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,G.utilToBase)(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>4)continue;const i=4-s.length;for(let e=s.length-1;e>=0;e--)r[4*n+e+i]=s[e]}this.valueBlock.value=e}}t.UniversalString=I;class R extends(i(s)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class D extends l{constructor(e={}){super(e,R),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);this.valueBlock.value=e}}class J extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}t.NumericString=J;class V extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}t.PrintableString=V;class j extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}t.TeletexString=j;class M extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}t.VideotexString=M;class F extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}t.IA5String=F;class _ extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}t.GraphicString=_;class $ extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}t.VisibleString=$;class z extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}t.GeneralString=z;class q extends D{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}t.CharacterString=q;class W extends ${constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=(0,G.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=(0,G.padNumber)(this.month,2),e[2]=(0,G.padNumber)(this.day,2),e[3]=(0,G.padNumber)(this.hour,2),e[4]=(0,G.padNumber)(this.minute,2),e[5]=(0,G.padNumber)(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}t.UTCTime=W;class Z extends ${constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,n="",s="",i=0,o=0,a=0;if("Z"===e[e.length-1])n=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");n=e}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=n.indexOf("+"),r="";if(-1===t&&(t=n.indexOf("-"),e=-1),-1!==t){if(r=n.substr(t+1),n=n.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let s=new Number(r.substr(0,2));if(isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");if(o=e*s,4===r.length){if(s=new Number(r.substr(2,2)),isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");a=e*s}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const e=new Number(`0${n.substr(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=e.valueOf(),s=n.substr(0,c)}else s=n;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const l=t.exec(s);if(null===l)throw new Error("Wrong input string for convertion");for(let e=1;e<l.length;e++)switch(e){case 1:this.year=parseInt(l[e],10);break;case 2:this.month=parseInt(l[e],10);break;case 3:this.day=parseInt(l[e],10);break;case 4:this.hour=parseInt(l[e],10)+o;break;case 5:this.minute=parseInt(l[e],10)+a;break;case 6:this.second=parseInt(l[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push((0,G.padNumber)(this.year,4)),e.push((0,G.padNumber)(this.month,2)),e.push((0,G.padNumber)(this.day,2)),e.push((0,G.padNumber)(this.hour,2)),e.push((0,G.padNumber)(this.minute,2)),e.push((0,G.padNumber)(this.second,2)),0!==this.millisecond&&(e.push("."),e.push((0,G.padNumber)(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}t.GeneralizedTime=Z;class X extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}t.DATE=X;class Y extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}t.TimeOfDay=Y;class Q extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}t.DateTime=Q;class ee extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}t.Duration=ee;class te extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}t.TIME=te;class re{constructor(e={}){this.value=(0,G.getParametersValue)(e,"value",[]),this.optional=(0,G.getParametersValue)(e,"optional",!1)}}t.Choice=re;class ne{constructor(e={}){this.name=(0,G.getParametersValue)(e,"name",""),this.optional=(0,G.getParametersValue)(e,"optional",!1)}}t.Any=ne;class se{constructor(e={}){this.name=(0,G.getParametersValue)(e,"name",""),this.optional=(0,G.getParametersValue)(e,"optional",!1),this.value=(0,G.getParametersValue)(e,"value",new ne),this.local=(0,G.getParametersValue)(e,"local",!1)}}t.Repeated=se;function ie(e,t,r){const n=t;let i=new l({},Object);if(!1===(0,G.checkBufferParams)(new s,e,t,r))return i.error="Wrong input parameters",{offset:-1,result:i};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:i};let o=i.idBlock.fromBER(e,t,r);if(i.warnings.concat(i.idBlock.warnings),-1===o)return i.error=i.idBlock.error,{offset:-1,result:i};if(t=o,r-=i.idBlock.blockLength,o=i.lenBlock.fromBER(e,t,r),i.warnings.concat(i.lenBlock.warnings),-1===o)return i.error=i.lenBlock.error,{offset:-1,result:i};if(t=o,r-=i.lenBlock.blockLength,!1===i.idBlock.isConstructed&&!0===i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let a=l;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&!1===i.idBlock.isHexOnly)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(!0===i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};a=g;break;case 1:a=d;break;case 2:a=C;break;case 3:a=S;break;case 4:a=B;break;case 5:a=w;break;case 6:a=U;break;case 10:a=N;break;case 12:a=L;break;case 14:a=te;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:a=v;break;case 17:a=k;break;case 18:a=J;break;case 19:a=V;break;case 20:a=j;break;case 21:a=M;break;case 22:a=F;break;case 23:a=W;break;case 24:a=Z;break;case 25:a=_;break;case 26:a=$;break;case 27:a=z;break;case 28:a=I;break;case 29:a=q;break;case 30:a=T;break;case 31:a=X;break;case 32:a=Y;break;case 33:a=Q;break;case 34:a=ee;break;default:{let n;(n=!0===i.idBlock.isConstructed?new y:new u).idBlock=i.idBlock,n.lenBlock=i.lenBlock,n.warnings=i.warnings,o=(i=n).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:a=!0===i.idBlock.isConstructed?y:u}return o=(i=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(i,a)).fromBER(e,t,!0===i.lenBlock.isIndefiniteForm?r:i.lenBlock.length),i.valueBeforeDecode=e.slice(n,n+i.blockLength),{offset:o,result:i}}function oe(e){if(0===e.byteLength){const e=new l({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ie(e,0,e.byteLength)}function ae(e,t,r){if(r instanceof re){for(let n=0;n<r.value.length;n++){if(!0===ae(e,t,r.value[n]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof ne)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=new Uint8Array(r.idBlock.valueHex),s=new Uint8Array(t.idBlock.valueHex);if(n.length!==s.length)return{verified:!1,result:e};for(let t=0;t<n.length;t++)if(n[t]!==s[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let n=0,s={verified:!1},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof se&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let o=0;o<i;o++)if(o-n>=t.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof se){if(!1===(s=ae(e,t.valueBlock.value[o],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),s;n++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};void 0===(n="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e)[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(t.valueBlock.value[o])}}else if(!1===(s=ae(e,t.valueBlock.value[o-n],r.valueBlock.value[o])).verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),s;n++}if(!1===s.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const n=oe(t.valueBlock.valueHex);if(-1===n.offset){const t={verified:!1,result:n.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return ae(e,n.result,r.primitiveSchema)}return{verified:!0,result:e}}t.RawData=class{constructor(e={}){this.data=(0,G.getParametersValue)(e,"data",new ArrayBuffer(0))}fromBER(e,t,r){return this.data=e.slice(t,r),t+r}toBER(e=!1){return this.data}}});J(z);z.RawData,z.Repeated,z.Any,z.Choice,z.TIME,z.Duration,z.DateTime,z.TimeOfDay,z.DATE,z.GeneralizedTime,z.UTCTime,z.CharacterString,z.GeneralString,z.VisibleString,z.GraphicString,z.IA5String,z.VideotexString,z.TeletexString,z.PrintableString,z.NumericString,z.UniversalString,z.BmpString,z.Utf8String,z.ObjectIdentifier,z.Enumerated;var q=z.Integer,W=(z.BitString,z.OctetString,z.Null,z.Set,z.Sequence,z.Boolean,z.EndOfContent,z.Constructed,z.Primitive,z.BaseBlock,z.fromBER,z.compareSchema,z.verifySchema,z.fromJSON,V(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const n={fromASN:e=>e instanceof z.Null?null:e.valueBeforeDecode,toASN:e=>{if(null===e)return new z.Null;const t=z.fromBER(e);if(t.result.error)throw new Error(t.result.error);return t.result}},s={fromASN:e=>!e.valueBlock.valueDec&&e.valueBlock.valueHex.byteLength>0?e.valueBlock.toString():e.valueBlock.valueDec,toASN:e=>new z.Integer({value:e})},i={fromASN:e=>e.valueBlock.valueDec,toASN:e=>new z.Enumerated({value:e})},o={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new z.Integer({valueHex:e})},a={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new z.BitString({valueHex:e})},c={fromASN:e=>e.valueBlock.toString(),toASN:e=>new z.ObjectIdentifier({value:e})},l={fromASN:e=>e.valueBlock.value,toASN:e=>new z.Boolean({value:e})},h={fromASN:e=>e.valueBlock.valueHex,toASN:e=>new z.OctetString({valueHex:e})};function u(e){return{fromASN:e=>e.valueBlock.value,toASN:t=>new e({value:t})}}const f=u(z.Utf8String),y=u(z.BmpString),p=u(z.UniversalString),g=u(z.NumericString),m=u(z.PrintableString),d=u(z.TeletexString),v=u(z.VideotexString),k=u(z.IA5String),w=u(z.GraphicString),b=u(z.VisibleString),B=u(z.GeneralString),A=u(z.CharacterString),S={fromASN:e=>e.toDate(),toASN:e=>new z.UTCTime({valueDate:e})},x={fromASN:e=>e.toDate(),toASN:e=>new z.GeneralizedTime({valueDate:e})};var C,N,E=Object.freeze({AsnAnyConverter:n,AsnIntegerConverter:s,AsnEnumeratedConverter:i,AsnIntegerArrayBufferConverter:o,AsnBitStringConverter:a,AsnObjectIdentifierConverter:c,AsnBooleanConverter:l,AsnOctetStringConverter:h,AsnUtf8StringConverter:f,AsnBmpStringConverter:y,AsnUniversalStringConverter:p,AsnNumericStringConverter:g,AsnPrintableStringConverter:m,AsnTeletexStringConverter:d,AsnVideotexStringConverter:v,AsnIA5StringConverter:k,AsnGraphicStringConverter:w,AsnVisibleStringConverter:b,AsnGeneralStringConverter:B,AsnCharacterStringConverter:A,AsnUTCTimeConverter:S,AsnGeneralizedTimeConverter:x});(C=t.AsnTypeTypes||(t.AsnTypeTypes={}))[C.Sequence=0]="Sequence",C[C.Set=1]="Set",C[C.Choice=2]="Choice",(N=t.AsnPropTypes||(t.AsnPropTypes={}))[N.Any=0]="Any",N[N.Boolean=1]="Boolean",N[N.OctetString=2]="OctetString",N[N.BitString=3]="BitString",N[N.Integer=4]="Integer",N[N.Enumerated=5]="Enumerated",N[N.ObjectIdentifier=6]="ObjectIdentifier",N[N.Utf8String=7]="Utf8String",N[N.BmpString=8]="BmpString",N[N.UniversalString=9]="UniversalString",N[N.NumericString=10]="NumericString",N[N.PrintableString=11]="PrintableString",N[N.TeletexString=12]="TeletexString",N[N.VideotexString=13]="VideotexString",N[N.IA5String=14]="IA5String",N[N.GraphicString=15]="GraphicString",N[N.VisibleString=16]="VisibleString",N[N.GeneralString=17]="GeneralString",N[N.CharacterString=18]="CharacterString",N[N.UTCTime=19]="UTCTime",N[N.GeneralizedTime=20]="GeneralizedTime",N[N.DATE=21]="DATE",N[N.TimeOfDay=22]="TimeOfDay",N[N.DateTime=23]="DateTime",N[N.Duration=24]="Duration",N[N.TIME=25]="TIME",N[N.Null=26]="Null";const K=z;const U=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)}get(e){const t=this.items.get(e);if(!t)throw new Error("Cannot get schema for current target");return t}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const r={type:t.AsnTypeTypes.Sequence,items:{}},n=this.findParentSchema(e);return n&&(Object.assign(r,n),r.items=Object.assign({},r.items,n.items)),r}create(e,r){const n=this.items.get(e)||this.createDefault(e),s=[];for(const e in n.items){const i=n.items[e],o=r?e:"";let a;if("number"==typeof i.type){const e=t.AsnPropTypes[i.type],r=K[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);a=new r({name:o})}else a=new K.Any({name:o});const c=!!i.optional||void 0!==i.defaultValue;if(i.repeated&&(a.name="",a=new K.Repeated({name:o,value:a})),null!==i.context&&void 0!==i.context)if(i.implicit)if("number"==typeof i.type)s.push(new K.Primitive({name:o,optional:c,idBlock:{tagClass:3,tagNumber:i.context}}));else{this.cache(i.type);const e=this.get(i.type).schema.valueBlock.value;s.push(new K.Constructed({name:o,optional:c,idBlock:{tagClass:3,tagNumber:i.context},value:e}))}else s.push(new K.Constructed({optional:c,idBlock:{tagClass:3,tagNumber:i.context},value:[a]}));else a.optional=c,s.push(a)}switch(n.type){case t.AsnTypeTypes.Sequence:return new K.Sequence({value:s,name:""});case t.AsnTypeTypes.Set:return new K.Set({value:s,name:""});case t.AsnTypeTypes.Choice:return new K.Choice({value:s,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}};function O(e){return e&&e.prototype?!(!e.prototype.toASN||!e.prototype.fromASN)||O(e.prototype):!!(e&&e.toASN&&e.fromASN)}const L=z;const P=z;t.AsnProp=(e=>(r,n)=>{let s;U.has(r.constructor)?s=U.get(r.constructor):(s=U.createDefault(r.constructor),U.set(r.constructor,s));const i=Object.assign({},e);if("number"==typeof i.type&&!i.converter){const s=`Asn${t.AsnPropTypes[e.type]}Converter`,o=E[s];if(!o)throw new Error(`Cannot get '${s}' for property '${n}' of ${r.constructor.name}`);i.converter=o}s.items[n]=i}),t.AsnType=(e=>t=>{const r=U.get(t);Object.assign(r,e)}),t.AsnParser=class{static parse(e,t,r){let n;if(e instanceof ArrayBuffer)n=e;else if(void 0!==typeof Buffer&&Buffer.isBuffer(e))n=new Uint8Array(e).buffer;else{if(!ArrayBuffer.isView(e))throw new TypeError("Wrong type of 'data' argument");n=e.buffer}const s=L.fromBER(n);if(s.result.error)throw new Error(s.result.error);return this.fromASN(s.result,t,r)}static fromASN(e,r,n){if(O(r))return(n||new r).fromASN(e);const s=U.get(r);U.cache(r);let i=s.schema;if(e.constructor===L.Constructed&&s.type!==t.AsnTypeTypes.Choice){i=new L.Constructed({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:s.schema.valueBlock.value});for(const t in s.items)delete e[t]}const o=L.compareSchema(e,e,i);if(!o.verified)throw new Error(`Data does not match to ${r.name} ASN1 schema. ${o.result.error}`);const a=n||new r;for(const r in s.items){if(!e[r])continue;const n=s.items[r];if("number"==typeof n.type){const s=n.converter;if(!s)throw new Error("Converter is empty");if(n.repeated)a[r]=Array.from(e[r],e=>s.fromASN(e));else{let i=e[r];if(n.implicit){const e=t.AsnPropTypes[n.type],r=L[e];if(!r)throw new Error(`Cannot get '${e}' class from asn1js module`);const s=new r;s.valueBlock=i.valueBlock,i=L.fromBER(s.toBER(!1)).result}a[r]=s.fromASN(i)}}else n.repeated?a[r]=Array.from(e[r],e=>this.fromASN(e,n.type)):a[r]=this.fromASN(e[r],n.type)}return a._cache={asn1:e},a}},t.AsnSerializer=class{static serialize(e){return this.toASN(e).toBER(!1)}static toASN(e){if(e&&O(e.constructor))return e.toASN();const n=e.constructor,s=U.get(n);U.cache(n);let i,o=[];for(const i in s.items){const a=s.items[i],c=e[i];if(void 0===c||a.defaultValue===c)continue;let l;if("number"==typeof a.type){const e=a.converter;if(!e)throw new Error(`Property '${i}' doesn't have converter for type ${t.AsnPropTypes[a.type]} in schema '${n.name}'`);l=a.repeated?Array.from(c,t=>e.toASN(t)):e.toASN(c)}else l=a.repeated?Array.from(c,e=>this.toASN(e)):this.toASN(c);if(null!==a.context&&void 0!==a.context)if(a.implicit)if("number"==typeof a.type){const e={};e.valueHex=l.valueBlock.toBER(),o.push(new P.Primitive(r({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context}},e)))}else o.push(new P.Constructed({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:l.valueBlock.value}));else o.push(new P.Constructed({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[l]}));else a.repeated?o=o.concat(l):o.push(l)}switch(s.type){case t.AsnTypeTypes.Sequence:i=new P.Sequence({value:o});break;case t.AsnTypeTypes.Set:i=new P.Set({value:o});break;case t.AsnTypeTypes.Choice:if(!o[0])throw new Error(`Schema '${n.name}' has wrong data. Choice cannot be empty.`);i=o[0]}return i}},t.AsnAnyConverter=n,t.AsnIntegerConverter=s,t.AsnEnumeratedConverter=i,t.AsnIntegerArrayBufferConverter=o,t.AsnBitStringConverter=a,t.AsnObjectIdentifierConverter=c,t.AsnBooleanConverter=l,t.AsnOctetStringConverter=h,t.AsnUtf8StringConverter=f,t.AsnBmpStringConverter=y,t.AsnUniversalStringConverter=p,t.AsnNumericStringConverter=g,t.AsnPrintableStringConverter=m,t.AsnTeletexStringConverter=d,t.AsnVideotexStringConverter=v,t.AsnIA5StringConverter=k,t.AsnGraphicStringConverter=w,t.AsnVisibleStringConverter=b,t.AsnGeneralStringConverter=B,t.AsnCharacterStringConverter=A,t.AsnUTCTimeConverter=S,t.AsnGeneralizedTimeConverter=x}));J(W);var Z=W.AsnTypeTypes,X=W.AsnPropTypes,Y=W.AsnProp,Q=W.AsnType,ee=W.AsnParser,te=W.AsnSerializer,re=(W.AsnAnyConverter,W.AsnIntegerConverter),ne=(W.AsnEnumeratedConverter,W.AsnIntegerArrayBufferConverter,W.AsnBitStringConverter,W.AsnObjectIdentifierConverter,W.AsnBooleanConverter,W.AsnOctetStringConverter,W.AsnUtf8StringConverter,W.AsnBmpStringConverter,W.AsnUniversalStringConverter,W.AsnNumericStringConverter,W.AsnPrintableStringConverter,W.AsnTeletexStringConverter,W.AsnVideotexStringConverter,W.AsnIA5StringConverter,W.AsnGraphicStringConverter,W.AsnVisibleStringConverter,W.AsnGeneralStringConverter,W.AsnCharacterStringConverter,W.AsnUTCTimeConverter,W.AsnGeneralizedTimeConverter,V(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});class n extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class s extends n{constructor(e,t,r){super(t,r),this.schema=e}}class i extends s{constructor(e,t,r){super(e,`JSON doesn't match to '${e.target.name}' schema. ${t}`,r)}}class o extends n{}class a extends n{constructor(e,t,r){super(`Cannot serialize by '${e}' schema. ${t}`,r),this.schemaName=e}}class c extends i{constructor(e,t,r={}){super(e,"Some keys doesn't match to schema"),this.keys=t,this.errors=r}}var l;function h(e,r){if(!function(e,r){switch(r){case t.JsonPropTypes.Boolean:return"boolean"==typeof e;case t.JsonPropTypes.Number:return"number"==typeof e;case t.JsonPropTypes.String:return"string"==typeof e}return!0}(e,r))throw new TypeError(`Value must be ${t.JsonPropTypes[r]}`)}function u(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||u(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}(l=t.JsonPropTypes||(t.JsonPropTypes={}))[l.Any=0]="Any",l[l.Boolean=1]="Boolean",l[l.Number=2]="Number",l[l.String=3]="String";const f="default",y=new class{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const e in r.names)t.names[e]=Object.assign({},r.names[e])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}};class p{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof e)throw new o("Incoming value must be string");if(!t.exec(e))throw new o(`Value doesn't match to pattern '${t.toString()}'`)}}class g{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(h(e,t.JsonPropTypes.Number),!(this.min<=e&&e<=this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new o(`Value doesn't match to diapason [${e},${t}]`)}}}class m{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(h(e,t.JsonPropTypes.Number),!(this.min<e&&e<this.max)){const e=this.min===Number.MIN_VALUE?"MIN":this.min,t=this.max===Number.MAX_VALUE?"MAX":this.max;throw new o(`Value doesn't match to diapason (${e},${t})`)}}}class d{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(void 0===this.length){if(void 0!==this.minLength&&e.length<this.minLength)throw new o(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&e.length>this.maxLength)throw new o(`Value length must be less than ${this.maxLength}.`)}else if(e.length!==this.length)throw new o(`Value length must be exactly ${this.length}.`)}}class v{constructor(e){this.enumeration=e}validate(e){if(h(e,t.JsonPropTypes.String),!this.enumeration.includes(e))throw new o(`Value must be one of ${this.enumeration.map(e=>`'${e}'`).join(", ")}`)}}class k{static checkValues(e,t){const r=Array.isArray(e)?e:[e];for(const n of r)for(const r of t.validations)r instanceof d&&t.repeated?r.validate(e):r.validate(n)}static checkTypes(e,t){if(t.repeated&&!Array.isArray(e))throw new TypeError("Value must be Array");if("number"==typeof t.type){const r=Array.isArray(e)?e:[e];for(const e of r)h(e,t.type)}}static getSchemaByName(e,t=f){return r({},e.names[f],e.names[t])}}class w extends k{static parse(e,t){const r=JSON.parse(e);return this.fromJSON(r,t)}static fromJSON(e,t){const n=t.targetSchema,s=t.schemaName||f,o=new n;if(u(o))return o.fromJSON(e);const a=y.get(n),l=this.getSchemaByName(a,s),h={};t.strictProperty&&!Array.isArray(e)&&w.checkStrictProperty(e,l,a);for(const n in l)try{const c=l[n],u=c.name||n,f=e[u];if(void 0===f&&(c.optional||void 0!==c.defaultValue))continue;if(!c.optional&&void 0===f)throw new i(a,`Property '${u}' is required.`);if(this.checkTypes(f,c),this.checkValues(f,c),"number"==typeof c.type)c.converter?c.repeated?o[n]=f.map(e=>c.converter.fromJSON(e,o)):o[n]=c.converter.fromJSON(f,o):o[n]=f;else{const e=r({},t,{targetSchema:c.type,schemaName:s});c.repeated?o[n]=f.map(t=>this.fromJSON(t,e)):o[n]=this.fromJSON(f,e)}}catch(e){if(e instanceof i||(e=new i(a,`Property '${n}' is wrong. ${e.message}`,e)),!t.strictAllKeys)throw e;h[n]=e}const p=Object.keys(h);if(p.length)throw new c(a,p,h);return o}static checkStrictProperty(e,t,r){const n=Object.keys(e),s=Object.keys(t),i=[];for(const e of n)-1===s.indexOf(e)&&i.push(e);if(i.length)throw new c(r,i)}}t.JsonSerializer=class extends k{static serialize(e,t,r,n){const s=this.toJSON(e,t);return JSON.stringify(s,r,n)}static toJSON(e,t={}){let r,s=t.targetSchema;const i=t.schemaName||f;if(u(e))return e.toJSON();if(Array.isArray(e)){r=[];for(const n of e)r.push(this.toJSON(n,t))}else if("object"==typeof e){if(s&&!y.has(s))throw new n("Cannot get schema for `targetSchema` param");if(s=s||e.constructor,y.has(s)){const t=y.get(s);r={};const n=this.getSchemaByName(t,i);for(const o in n)try{const c=n[o],l=e[o];let h;if(c.optional&&void 0===l||void 0!==c.defaultValue&&l===c.defaultValue)continue;if(!c.optional&&void 0===l)throw new a(s.name,`Property '${o}' is required.`);h="number"==typeof c.type?c.converter?c.repeated?l.map(t=>c.converter.toJSON(t,e)):c.converter.toJSON(l,e):l:c.repeated?l.map(e=>this.toJSON(e,{schemaName:i})):this.toJSON(l,{schemaName:i}),this.checkTypes(h,c),this.checkValues(h,c),r[c.name||o]=h}catch(e){throw e instanceof a?e:new a(t.target.name,`Property '${o}' is wrong. ${e.message}`,e)}}else{r={};for(const t in e)r[t]=this.toJSON(e[t],{schemaName:i})}}else r=e;return r}},t.JsonParser=w,t.JsonProp=((e={})=>(r,n)=>{const s=`Cannot set type for ${n} property of ${r.constructor.name} schema`;let i;y.has(r.constructor)?(i=y.get(r.constructor)).target!==r.constructor&&(i=y.create(r.constructor),y.set(r.constructor,i)):(i=y.create(r.constructor),y.set(r.constructor,i));const o={type:t.JsonPropTypes.Any,validations:[]},a=Object.assign(o,e);if(a.validations=function(e){const r=[];return e.pattern&&r.push(new p(e.pattern)),e.type!==t.JsonPropTypes.Number&&e.type!==t.JsonPropTypes.Any||(void 0===e.minInclusive&&void 0===e.maxInclusive||r.push(new g(e.minInclusive,e.maxInclusive)),void 0===e.minExclusive&&void 0===e.maxExclusive||r.push(new m(e.minExclusive,e.maxExclusive)),void 0!==e.enumeration&&r.push(new v(e.enumeration))),(e.type===t.JsonPropTypes.String||e.repeated||e.type===t.JsonPropTypes.Any)&&(void 0===e.length&&void 0===e.minLength&&void 0===e.maxLength||r.push(new d(e.length,e.minLength,e.maxLength))),r}(a),"number"!=typeof a.type&&!y.has(a.type)&&!u(a.type))throw new Error(`${s}. Assigning type doesn't have schema.`);let c;c=Array.isArray(e.schema)?e.schema:[e.schema||f];for(const e of c)i.names[e]||(i.names[e]={}),i.names[e][n]=a})}));J(ne);ne.JsonPropTypes;var se=ne.JsonSerializer,ie=ne.JsonParser,oe=ne.JsonProp;let ae=class{constructor(e){e&&(this.value=e)}};a([Y({type:X.ObjectIdentifier})],ae.prototype,"value",void 0),ae=a([Q({type:Z.Choice})],ae);class ce{constructor(e){Object.assign(this,e)}}a([Y({type:X.ObjectIdentifier})],ce.prototype,"algorithm",void 0),a([Y({type:X.Any,optional:!0})],ce.prototype,"parameters",void 0);class le{constructor(){this.version=0,this.privateKeyAlgorithm=new ce,this.privateKey=new ArrayBuffer(0)}}a([Y({type:X.Integer})],le.prototype,"version",void 0),a([Y({type:ce})],le.prototype,"privateKeyAlgorithm",void 0),a([Y({type:X.OctetString})],le.prototype,"privateKey",void 0),a([Y({type:X.Any,optional:!0})],le.prototype,"attributes",void 0);class he{constructor(){this.publicKeyAlgorithm=new ce,this.publicKey=new ArrayBuffer(0)}}a([Y({type:ce})],he.prototype,"publicKeyAlgorithm",void 0),a([Y({type:X.BitString})],he.prototype,"publicKey",void 0);const ue={fromJSON:e=>h.FromBase64Url(e),toJSON:e=>h.ToBase64Url(new Uint8Array(e))};var fe;function ye(...e){const t=new Uint8Array(e.map(e=>e.length).reduce((e,t)=>e+t));let r=0;return e.forEach((e,n)=>{for(let n=0;n<e.length;n++)t[r+n]=e[n];r+=e.length}),t}!function(e){e.Unknown="Unknown",e.IE="Internet Explorer",e.Safari="Safari",e.Edge="Edge",e.Chrome="Chrome",e.Firefox="Firefox Mozilla",e.Mobile="Mobile"}(fe||(fe={}));const pe={fromASN:e=>{const t=e.valueBlock.valueHex;return new Uint8Array(t)[0]?e.valueBlock.valueHex:e.valueBlock.valueHex.slice(1)},toASN:e=>{const t=new Uint8Array(e)[0]>127?ye(new Uint8Array([0]),new Uint8Array(e)):new Uint8Array(e);return new q({valueHex:new Uint8Array(t).buffer})}};class ge{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}a([Y({type:X.Integer,converter:re})],ge.prototype,"version",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"n",converter:ue})],ge.prototype,"modulus",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"e",converter:ue})],ge.prototype,"publicExponent",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"d",converter:ue})],ge.prototype,"privateExponent",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"p",converter:ue})],ge.prototype,"prime1",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"q",converter:ue})],ge.prototype,"prime2",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"dp",converter:ue})],ge.prototype,"exponent1",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"dq",converter:ue})],ge.prototype,"exponent2",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"qi",converter:ue})],ge.prototype,"coefficient",void 0),a([Y({type:X.Any,optional:!0})],ge.prototype,"otherPrimeInfos",void 0);class me{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}a([Y({type:X.Integer,converter:pe}),oe({name:"n",converter:ue})],me.prototype,"modulus",void 0),a([Y({type:X.Integer,converter:pe}),oe({name:"e",converter:ue})],me.prototype,"publicExponent",void 0);let de=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(4!==e[0])throw new u("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");const t=(e=new Uint8Array(this.value.slice(1))).length/2;return{x:h.ToBase64Url(e.buffer.slice(0,0+t)),y:h.ToBase64Url(e.buffer.slice(0+t,0+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=h.FromBase64Url(e.x),r=h.FromBase64Url(e.y),n=ye(new Uint8Array([4]),new Uint8Array(t),new Uint8Array(r));return this.value=new Uint8Array(n).buffer,this}};a([Y({type:X.OctetString})],de.prototype,"value",void 0),de=a([Q({type:Z.Choice})],de);class ve{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=h.FromBase64Url(e.d),"x"in e){const t=new de;t.fromJSON(e),this.publicKey=te.toASN(t).valueBlock.valueHex}return this}toJSON(){const e={};return e.d=h.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new de(this.publicKey).toJSON()),e}}a([Y({type:X.Integer,converter:re})],ve.prototype,"version",void 0),a([Y({type:X.OctetString})],ve.prototype,"privateKey",void 0),a([Y({context:0,type:X.Any,optional:!0})],ve.prototype,"parameters",void 0),a([Y({context:1,type:X.BitString,optional:!0})],ve.prototype,"publicKey",void 0);const ke={fromASN:e=>{const t=new Uint8Array(e.valueBlock.valueHex);return 0===t[0]?t.buffer.slice(1):t.buffer},toASN:e=>{const t=new Uint8Array(e);if(t[0]>127){const e=new Uint8Array(t.length+1);return e.set(t,1),new q({valueHex:e})}return new q({valueHex:e})}};class we{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}}a([Y({type:X.Integer,converter:ke})],we.prototype,"r",void 0),a([Y({type:X.Integer,converter:ke})],we.prototype,"s",void 0);class be extends P{constructor(e,t,n,s){super(),this.extractable=t,this.type=n,this.usages=s,this.algorithm=r({},e)}}function Be(e,t){return e.name.toUpperCase()===t.toUpperCase()}class Ae extends be{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:h.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new f("Unsupported algorithm name")}}}class Se{static checkLib(){if("undefined"==typeof asmCrypto)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static checkCryptoKey(e){if(!(e instanceof Ae))throw new TypeError("key: Is not AesCryptoKey")}static async generateKey(e,t,r){this.checkLib();const n=i.getRandomValues(new Uint8Array(e.length/8));return new Ae(e,t,r,n)}static async encrypt(e,t,r){return this.cipher(e,t,r,!0)}static async decrypt(e,t,r){return this.cipher(e,t,r,!1)}static async exportKey(e,t){switch(this.checkLib(),e){case"jwk":return t.toJSON();case"raw":return t.raw.buffer;default:throw new p("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,n,s){let i;switch(this.checkLib(),(i=d(t)?h.FromBase64Url(t.k):m.toArrayBuffer(t)).byteLength<<3){case 128:case 192:case 256:break;default:throw new p("keyData: Is wrong key length")}return new Ae({name:r.name,length:i.byteLength<<3},n,s,new Uint8Array(i))}static async cipher(e,t,r,n){this.checkLib();const s=n?"encrypt":"decrypt";let i;if(Be(e,Se.AesCBC)){const n=m.toArrayBuffer(e.iv);i=asmCrypto.AES_CBC[s](r,t.raw,void 0,n)}else if(Be(e,Se.AesGCM)){const n=m.toArrayBuffer(e.iv);let o;e.additionalData&&(o=m.toArrayBuffer(e.additionalData));const a=(e.tagLength||128)/8;i=asmCrypto.AES_GCM[s](r,t.raw,n,o,a)}else{if(!Be(e,Se.AesECB))throw new p("algorithm: Is not recognized");i=asmCrypto.AES_ECB[s](r,t.raw,!0)}return i.buffer}}Se.AesCBC="AES-CBC",Se.AesECB="AES-ECB",Se.AesGCM="AES-GCM";class xe extends w{async onGenerateKey(e,t,r){return Se.generateKey(e,t,r)}async onEncrypt(e,t,r){return Se.encrypt(e,t,r)}async onDecrypt(e,t,r){return Se.decrypt(e,t,r)}async onExportKey(e,t){return Se.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Se.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Se.checkCryptoKey(e)}}class Ce extends B{async onGenerateKey(e,t,r){return Se.generateKey(e,t,r)}async onEncrypt(e,t,r){return Se.encrypt(e,t,r)}async onDecrypt(e,t,r){return Se.decrypt(e,t,r)}async onExportKey(e,t){return Se.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Se.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Se.checkCryptoKey(e)}}class Ne extends A{async onGenerateKey(e,t,r){return Se.generateKey(e,t,r)}async onEncrypt(e,t,r){return Se.encrypt(e,t,r)}async onDecrypt(e,t,r){return Se.decrypt(e,t,r)}async onExportKey(e,t){return Se.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Se.importKey(e,t,r,n,s)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Se.checkCryptoKey(e)}}class Ee extends b{async onEncrypt(e,t,r){throw new Error("Method not implemented.")}async onDecrypt(e,t,r){throw new Error("Method not implemented.")}async onGenerateKey(e,t,r){throw new Error("Method not implemented.")}async onExportKey(e,t){throw new Error("Method not implemented.")}async onImportKey(e,t,r,n,s){throw new Error("Method not implemented.")}}class Ke extends S{async onEncrypt(e,t,r){throw new Error("Method not implemented.")}async onDecrypt(e,t,r){throw new Error("Method not implemented.")}async onGenerateKey(e,t,r){throw new Error("Method not implemented.")}async onExportKey(e,t){throw new Error("Method not implemented.")}async onImportKey(e,t,r,n,s){throw new Error("Method not implemented.")}}class Ue extends be{constructor(e,t,r,n,s){super(e,t,r,n),this.data=s}}class Oe{static checkLib(){if("undefined"==typeof asmCrypto)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static checkCryptoKey(e){if(!(e instanceof Ue))throw new TypeError("key: Is not RsaCryptoKey")}static async generateKey(e,t,n){this.checkLib();const s=3===e.publicExponent[0]?3:65537,i=asmCrypto.RSA.generateKey(e.modulusLength,s),o=e.hash.name.toUpperCase();return{privateKey:new Ue(r({},e,{hash:{name:o}}),t,"private",n.filter(e=>~this.privateUsages.indexOf(e)),i),publicKey:new Ue(r({},e,{hash:{name:o}}),!0,"public",n.filter(e=>~this.publicUsages.indexOf(e)),i)}}static async exportKey(e,t){switch(this.checkLib(),e){case"pkcs8":return this.exportPkcs8Key(t);case"spki":return this.exportSpkiKey(t);case"jwk":return this.exportJwkKey(t);default:throw new p("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(e,t,n,s,i){let o;switch(this.checkLib(),e){case"pkcs8":o=this.importPkcs8Key(t);break;case"spki":o=this.importSpkiKey(t);break;case"jwk":o=this.importJwkKey(t);break;default:throw new p("format: Must be 'jwk', 'pkcs8' or 'spki'")}return new Ue(r({publicExponent:1===o[1][1]?o[1].slice(1):o[1].slice(3),modulusLength:o[0].byteLength<<3},n),s,2===o.length?"public":"private",i,o)}static exportPkcs8Key(e){const t=new le;return t.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",t.privateKeyAlgorithm.parameters=null,t.privateKey=te.serialize(this.exportAsmKey(e.data)),te.serialize(t)}static importPkcs8Key(e){const t=ee.parse(e,le),r=ee.parse(t.privateKey,ge);return this.importAsmKey(r)}static importSpkiKey(e){const t=ee.parse(e,he),r=ee.parse(t.publicKey,me);return this.importAsmKey(r)}static exportSpkiKey(e){const t=new me;t.modulus=e.data[0].buffer,t.publicExponent=1===e.data[1][1]?e.data[1].buffer.slice(1):e.data[1].buffer.slice(3);const r=new he;return r.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.publicKeyAlgorithm.parameters=null,r.publicKey=te.serialize(t),te.serialize(r)}static importJwkKey(e){let t;return t=e.d?ie.fromJSON(e,{targetSchema:ge}):ie.fromJSON(e,{targetSchema:me}),this.importAsmKey(t)}static exportJwkKey(e){const t=this.exportAsmKey(e.data),r=se.toJSON(t);return r.ext=!0,r.key_ops=e.usages,r.kty="RSA",r.alg=this.getJwkAlgorithm(e.algorithm),r}static getJwkAlgorithm(e){switch(e.name.toUpperCase()){case"RSA-OAEP":const t=/(\d+)$/.exec(e.hash.name)[1];return`RSA-OAEP${"1"!==t?`-${t}`:""}`;case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(e.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(e.hash.name)[1]}`;default:throw new p("algorithm: Is not recognized")}}static exportAsmKey(e){let t;if(e.length>2){const r=new ge;r.privateExponent=e[2].buffer,r.prime1=e[3].buffer,r.prime2=e[4].buffer,r.exponent1=e[5].buffer,r.exponent2=e[6].buffer,r.coefficient=e[7].buffer,t=r}else t=new me;return t.modulus=e[0].buffer,t.publicExponent=1===e[1][1]?e[1].buffer.slice(1):e[1].buffer.slice(3),t}static importAsmKey(e){const t=new Uint8Array(4-e.publicExponent.byteLength),r=[new Uint8Array(e.modulus),ye(t,new Uint8Array(e.publicExponent))];return e instanceof ge&&(r.push(new Uint8Array(e.privateExponent)),r.push(new Uint8Array(e.prime1)),r.push(new Uint8Array(e.prime2)),r.push(new Uint8Array(e.exponent1)),r.push(new Uint8Array(e.exponent2)),r.push(new Uint8Array(e.coefficient))),r}}Oe.RsaSsa="RSASSA-PKCS1-v1_5",Oe.RsaPss="RSA-PSS",Oe.RsaOaep="RSA-OAEP",Oe.privateUsages=["sign","decrypt","unwrapKey"],Oe.publicUsages=["verify","encrypt","wrapKey"];class Le extends K{async onGenerateKey(e,t,r){return Oe.generateKey(e,t,r)}async onExportKey(e,t){return Oe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Oe.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Oe.checkLib(),this.cipher(e,t,r,!0)}async onDecrypt(e,t,r){return Oe.checkLib(),this.cipher(e,t,r,!1)}cipher(e,t,r,n){const s=this.getOperation(t.algorithm,n);let i;return e.label&&(i=m.toArrayBuffer(e.label)),s(r,t.data,i).slice(0).buffer}getOperation(e,t){const r=t?"encrypt":"decrypt";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_OAEP_SHA1[r];case"SHA-256":return asmCrypto.RSA_OAEP_SHA256[r];case"SHA-512":return asmCrypto.RSA_OAEP_SHA512[r];default:throw new f("keyAlgorithm.hash: Is not recognized")}}}class Pe extends E{async onGenerateKey(e,t,r){return Oe.generateKey(e,t,r)}async onExportKey(e,t){return Oe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Oe.importKey(e,t,r,n,s)}async onSign(e,t,r){return Oe.checkLib(),this.getOperation(t.algorithm,!0)(r,t.data,e.saltLength).buffer}async onVerify(e,t,r,n){return Oe.checkLib(),this.getOperation(t.algorithm,!1)(r,n,t.data,e.saltLength)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Oe.checkCryptoKey(e)}getOperation(e,t){const r=t?"sign":"verify";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_PSS_SHA1[r];case"SHA-256":return asmCrypto.RSA_PSS_SHA256[r];case"SHA-512":return asmCrypto.RSA_PSS_SHA512[r];default:throw new f("keyAlgorithm.hash: Is not recognized")}}}class Te extends N{async onGenerateKey(e,t,r){return Oe.generateKey(e,t,r)}async onExportKey(e,t){return Oe.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Oe.importKey(e,t,r,n,s)}async onSign(e,t,r){return Oe.checkLib(),this.getOperation(t.algorithm,!0)(r,t.data).buffer}async onVerify(e,t,r,n){return Oe.checkLib(),this.getOperation(t.algorithm,!1)(r,n,t.data)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),Oe.checkCryptoKey(e)}getOperation(e,t){const r=t?"sign":"verify";switch(e.hash.name){case"SHA-1":return asmCrypto.RSA_PKCS1_v1_5_SHA1[r];case"SHA-256":return asmCrypto.RSA_PKCS1_v1_5_SHA256[r];case"SHA-512":return asmCrypto.RSA_PKCS1_v1_5_SHA512[r];default:throw new f("keyAlgorithm.hash: Is not recognized")}}}const He={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10"};function Ie(e){const t=He[e];if(!t)throw new p(`Cannot convert WebCrypto named curve '${e}' to OID`);return t}class Re extends be{constructor(e,t,r,n,s){super(e,t,r,n),this.data=s}}class De{static checkLib(){if("undefined"==typeof elliptic)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project")}static async generateKey(e,t,n){this.checkLib();const s=this.initEcKey(e.namedCurve).genKeyPair();return s.getPublic(),{privateKey:new Re(r({},e),t,"private",n.filter(e=>~this.privateUsages.indexOf(e)),s),publicKey:new Re(r({},e),!0,"public",n.filter(e=>~this.publicUsages.indexOf(e)),s)}}static checkCryptoKey(e){if(!(e instanceof Re))throw new TypeError("key: Is not EcCryptoKey")}static concat(...e){const t=new Uint8Array(e.map(e=>e.length).reduce((e,t)=>e+t));let r=0;return e.forEach((e,n)=>{for(let n=0;n<e.length;n++)t[r+n]=e[n];r+=e.length}),t}static async exportKey(e,t){switch(this.checkLib(),e){case"pkcs8":return this.exportPkcs8Key(t);case"spki":return this.exportSpkiKey(t);case"jwk":return this.exportJwkKey(t);case"raw":return new Uint8Array(t.data.getPublic("der")).buffer;default:throw new p("format: Must be 'jwk', 'raw, 'pkcs8' or 'spki'")}}static async importKey(e,t,n,s,i){let o;switch(this.checkLib(),e){case"pkcs8":o=this.importPkcs8Key(t,n.namedCurve);break;case"spki":o=this.importSpkiKey(t,n.namedCurve);break;case"raw":o=this.importEcKey(new de(t),n.namedCurve);break;case"jwk":o=this.importJwkKey(t);break;default:throw new p("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}return new Re(r({},n),s,o.priv?"private":"public",i,o)}static getNamedCurve(e){const t=e.toUpperCase();let r="";if(["P-256","P-384","P-521"].indexOf(t)>-1)r=t.replace("-","").toLowerCase();else{if("K-256"!==t)throw new p(`Unsupported named curve '${e}'`);r="secp256k1"}return r}static initEcKey(e){return elliptic.ec(this.getNamedCurve(e))}static exportPkcs8Key(e){const t=new le;return t.privateKeyAlgorithm.algorithm=this.ASN_ALGORITHM,t.privateKeyAlgorithm.parameters=te.serialize(new ae(Ie(e.algorithm.namedCurve))),t.privateKey=te.serialize(this.exportEcKey(e)),te.serialize(t)}static importPkcs8Key(e,t){const r=ee.parse(e,le),n=ee.parse(r.privateKey,ve);return this.importEcKey(n,t)}static importSpkiKey(e,t){const r=ee.parse(e,he),n=new de(r.publicKey);return this.importEcKey(n,t)}static exportSpkiKey(e){const t=new de(new Uint8Array(e.data.getPublic("der")).buffer),r=new he;return r.publicKeyAlgorithm.algorithm=this.ASN_ALGORITHM,r.publicKeyAlgorithm.parameters=te.serialize(new ae(Ie(e.algorithm.namedCurve))),r.publicKey=t.value,te.serialize(r)}static importJwkKey(e){let t;return t=e.d?ie.fromJSON(e,{targetSchema:ve}):ie.fromJSON(e,{targetSchema:de}),this.importEcKey(t,e.crv)}static exportJwkKey(e){const t=this.exportEcKey(e),r=se.toJSON(t);return r.ext=!0,r.key_ops=e.usages,r.crv=e.algorithm.namedCurve,r.kty="EC",r}static exportEcKey(e){if("private"===e.type){const t=new ve,r=new Uint8Array(e.data.getPrivate("der").toArray()),n=new Uint8Array(this.getPointSize(e.algorithm.namedCurve)-r.length);return t.privateKey=ye(n,r),t.publicKey=new Uint8Array(e.data.getPublic("der")),t}if(e.data.pub)return new de(new Uint8Array(e.data.getPublic("der")).buffer);throw new Error("Cannot get private or public key")}static importEcKey(e,t){const r=this.initEcKey(t);return e instanceof de?r.keyFromPublic(new Uint8Array(e.value)):r.keyFromPrivate(new Uint8Array(e.privateKey))}static getPointSize(e){switch(e){case"P-256":case"K-256":return 32;case"P-384":return 48;case"P-521":return 66}throw new Error("namedCurve: Is not recognized")}}De.privateUsages=["sign","deriveKey","deriveBits"],De.publicUsages=["verify"],De.ASN_ALGORITHM="1.2.840.10045.2.1";class Je extends T{async onGenerateKey(e,t,r){return De.generateKey(e,t,r)}async onExportKey(e,t){return De.exportKey(e,t)}async onImportKey(e,t,r,n,s){return De.importKey(e,t,r,n,s)}async onDeriveBits(e,t,r){De.checkLib();const n=t.data.derive(e.public.data.getPublic());let s=new Uint8Array(n.toArray()),i=s.length;return i=i>32?i>48?66:48:32,s.length<i&&(s=De.concat(new Uint8Array(i-s.length),s)),s.slice(0,r/8).buffer}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),De.checkCryptoKey(e)}}function Ve(e){const t=new Uint8Array(e),r=[];for(let e=0;e<t.length;e++)r.push(t[e]);return r}function je(e,t){let r="";for(let t=0;t<e.length;t++){const n=e[t].toString(16);r+=n.length%2?"0"+n:n}if(t){let t=e.length;t=t>32?t>48?66:48:32,r.length/2<t&&(r=new Array(2*t-r.length+1).join("0")+r)}return r}class Me extends O{async onGenerateKey(e,t,r){return De.generateKey(e,t,r)}async onExportKey(e,t){return De.exportKey(e,t)}async onImportKey(e,t,r,n,s){return De.importKey(e,t,r,n,s)}async onSign(e,t,r){De.checkLib();const n=new et;let s;s=Ve(await n.subtle.digest(e.hash,r));const i=await t.data.sign(s);return function(e,t){e.length%2&&(e="0"+e);let r=new Uint8Array(e.length/2);for(let t=0;t<e.length;t++){const n=e.slice(t,++t+1);r[(t-1)/2]=parseInt(n,16)}if(t){let e=r.length;e=e>32?e>48?66:48:32,r.length<e&&(r=De.concat(new Uint8Array(e-r.length),r))}return r}(je(i.r.toArray(),!0)+je(i.s.toArray(),!0)).buffer}async onVerify(e,t,r,n){De.checkLib();const s=new et,i={r:new Uint8Array(r.slice(0,r.byteLength/2)),s:new Uint8Array(r.slice(r.byteLength/2))},o=Ve(await s.subtle.digest(e.hash,n));return t.data.verify(o,i)}async checkCryptoKey(e,t){super.checkCryptoKey(e,t),De.checkCryptoKey(e)}}class Fe{static checkLib(){if("undefined"==typeof asmCrypto)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}static async digest(e,t){return this.checkLib(),asmCrypto[e.name.replace("-","")].bytes(t).buffer}}class _e extends v{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}async onDigest(e,t){return Fe.digest(e,t)}}class $e extends _e{constructor(){super(...arguments),this.name="SHA-256"}}class Ge extends _e{constructor(){super(...arguments),this.name="SHA-512"}}class ze extends be{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}}class qe extends H{checkLib(){if("undefined"==typeof asmCrypto)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project")}async onImportKey(e,t,r,n,s){return this.checkLib(),new ze(r,n,s,m.toUint8Array(t))}async onDeriveBits(e,t,r){let n;this.checkLib();const s=m.toUint8Array(e.salt),i=t.raw;switch(e.hash.name.toUpperCase()){case"SHA-1":n=asmCrypto.PBKDF2_HMAC_SHA1.bytes(i,s,e.iterations,r>>3);break;case"SHA-256":n=asmCrypto.PBKDF2_HMAC_SHA256.bytes(i,s,e.iterations,r>>3);break;default:throw new p(`algorithm.hash: '${e.hash.name}' hash algorithm is not supported`)}return n.buffer}}class We extends be{constructor(e,t,r,n){super(e,t,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:h.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new f("Unsupported algorithm name")}}}class Ze{static checkLib(){if("undefined"==typeof des)throw new p("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/des.js' script to your project")}static async generateKey(e,t,r){this.checkLib();const n=i.getRandomValues(new Uint8Array(e.length/8));return new We(e,t,r,n)}static async exportKey(e,t){switch(this.checkLib(),e){case"jwk":return t.toJSON();case"raw":return t.raw.buffer;default:throw new p("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,n,s){let i;if(this.checkLib(),i=d(t)?h.FromBase64Url(t.k):m.toArrayBuffer(t),"DES-CBC"===r.name&&8!==i.byteLength||"DES-EDE3-CBC"===r.name&&24!==i.byteLength)throw new p("keyData: Is wrong key length");return new We({name:r.name,length:i.byteLength<<3},n,s,new Uint8Array(i))}static async encrypt(e,t,r){return this.cipher(e,t,r,!0)}static async decrypt(e,t,r){return this.cipher(e,t,r,!1)}static async cipher(e,t,r,n){this.checkLib();const s=n?"encrypt":"decrypt";let i;const o=m.toUint8Array(e.iv);switch(e.name.toUpperCase()){case"DES-CBC":i=des.CBC.instantiate(des.DES).create({key:t.raw,type:s,iv:o});break;case"DES-EDE3-CBC":i=des.CBC.instantiate(des.EDE).create({key:t.raw,type:s,iv:o});break;default:throw new p("algorithm: Is not recognized")}const a=i.update(new Uint8Array(r)).concat(i.final());return new Uint8Array(a).buffer}}class Xe extends x{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}async onGenerateKey(e,t,r){return Ze.generateKey(e,t,r)}async onExportKey(e,t){return Ze.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ze.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Ze.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ze.decrypt(e,t,r)}}class Ye extends x{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}async onGenerateKey(e,t,r){return Ze.generateKey(e,t,r)}async onExportKey(e,t){return Ze.exportKey(e,t)}async onImportKey(e,t,r,n,s){return Ze.importKey(e,t,r,n,s)}async onEncrypt(e,t,r){return Ze.encrypt(e,t,r)}async onDecrypt(e,t,r){return Ze.decrypt(e,t,r)}}class Qe extends D{constructor(){super(),this.browserInfo=function(){const e={name:fe.Unknown,version:"0"},t=self.navigator.userAgent;let r;return(r=/edge\/([\d\.]+)/i.exec(t))?(e.name=fe.Edge,e.version=r[1]):/msie/i.test(t)?(e.name=fe.IE,e.version=/msie ([\d\.]+)/i.exec(t)[1]):/Trident/i.test(t)?(e.name=fe.IE,e.version=/rv:([\d\.]+)/i.exec(t)[1]):/chrome/i.test(t)?(e.name=fe.Chrome,e.version=/chrome\/([\d\.]+)/i.exec(t)[1]):/firefox/i.test(t)?(e.name=fe.Firefox,e.version=/firefox\/([\d\.]+)/i.exec(t)[1]):/mobile/i.test(t)?(e.name=fe.Mobile,e.version=/mobile\/([\w]+)/i.exec(t)[1]):/safari/i.test(t)&&(e.name=fe.Safari,e.version=/version\/([\d\.]+)/i.exec(t)[1]),e}(),this.providers.set(new xe),this.providers.set(new Ee),this.providers.set(new Ce),this.providers.set(new Ne),this.providers.set(new Ke),this.providers.set(new Xe),this.providers.set(new Ye),this.providers.set(new Te),this.providers.set(new Pe),this.providers.set(new Le),this.providers.set(new Me),this.providers.set(new Je),this.providers.set(new _e),this.providers.set(new $e),this.providers.set(new Ge),this.providers.set(new qe)}static isAnotherKey(e){return"object"==typeof e&&"string"==typeof e.type&&"boolean"==typeof e.extractable&&"object"==typeof e.algorithm&&!(e instanceof be)}async digest(...e){return this.wrapNative("digest",...e)}async importKey(...e){return this.fixFirefoxEcImportPkcs8(e),this.wrapNative("importKey",...e)}async exportKey(...e){return await this.fixFirefoxEcExportPkcs8(e)||await this.wrapNative("exportKey",...e)}async generateKey(...e){return this.wrapNative("generateKey",...e)}async sign(...e){return this.wrapNative("sign",...e)}async verify(...e){return this.wrapNative("verify",...e)}async encrypt(...e){return this.wrapNative("encrypt",...e)}async decrypt(...e){return this.wrapNative("decrypt",...e)}async wrapKey(...e){return this.wrapNative("wrapKey",...e)}async unwrapKey(...e){return this.wrapNative("unwrapKey",...e)}async deriveBits(...e){return this.wrapNative("deriveBits",...e)}async deriveKey(...e){return this.wrapNative("deriveKey",...e)}async wrapNative(e,...t){~["generateKey","unwrapKey","deriveKey","importKey"].indexOf(e)&&this.fixAlgorithmName(t);try{if("digest"!==e||!t.some(e=>e instanceof be)){return n.info(`Call native '${e}' method`,t),await o[e].apply(o,t)}}catch(t){n.warn(`Error on native '${e}' calling. ${t.message}`,t)}if("wrapKey"===e)try{n.info("Trying to wrap key by using native functions",t);const e=await this.exportKey(t[0],t[1]),r="jwk"===t[0]?h.FromUtf8String(JSON.stringify(e)):e;return await this.encrypt(t[3],t[2],r)}catch(e){n.warn(`Cannot wrap key by native functions. ${e.message}`,e)}if("unwrapKey"===e)try{n.info("Trying to unwrap key by using native functions",t);const e=await this.decrypt(t[3],t[2],t[1]),r="jwk"===t[0]?JSON.parse(h.ToUtf8String(e)):e;return await this.importKey(t[0],r,t[4],t[5],t[6])}catch(e){n.warn(`Cannot unwrap key by native functions. ${e.message}`,e)}if("deriveKey"===e)try{n.info("Trying to derive key by using native functions",t);const e=await this.deriveBits(t[0],t[1],t[2].length);return await this.importKey("raw",e,t[2],t[3],t[4])}catch(e){n.warn(`Cannot derive key by native functions. ${e.message}`,e)}if("deriveBits"===e||"deriveKey"===e)for(const e of t)"object"==typeof e&&e.public&&Qe.isAnotherKey(e.public)&&(e.public=await this.castKey(e.public));for(let e=0;e<t.length;e++){const r=t[e];Qe.isAnotherKey(r)&&(t[e]=await this.castKey(r))}return super[e].apply(this,t)}async castKey(e){if(n.info("Cast native CryptoKey to linter key.",e),!e.extractable)throw new Error("Cannot cast unextractable crypto key");const t=this.getProvider(e.algorithm.name),r=await this.exportKey("jwk",e);return t.importKey("jwk",r,e.algorithm,!0,e.usages)}fixAlgorithmName(e){if(this.browserInfo.name===fe.Edge)for(let t=0;t<e.length;t++){const r=e[0];if("string"==typeof r){for(const n of this.providers.algorithms)if(n.toLowerCase()===r.toLowerCase()){e[t]=n;break}}else if("object"==typeof r&&"string"==typeof r.name)for(const e of this.providers.algorithms)e.toLowerCase()===r.name.toLowerCase()&&(r.name=e),("string"==typeof r.hash&&e.toLowerCase()===r.hash.toLowerCase()||"object"==typeof r.hash&&"string"==typeof r.hash.name&&e.toLowerCase()===r.hash.name.toLowerCase())&&(r.hash={name:e})}}fixFirefoxEcImportPkcs8(e){const t=this.prepareAlgorithm(e[2]),r=t.name.toUpperCase();if(this.browserInfo.name===fe.Firefox&&"pkcs8"===e[0]&&~["ECDSA","ECDH"].indexOf(r)&&~["P-256","P-384","P-521"].indexOf(t.namedCurve)){if(!m.isBufferSource(e[1]))throw new TypeError("data: Is not ArrayBuffer or ArrayBufferView");const r=m.toArrayBuffer(e[1]),n=ee.parse(r,le),s=ee.parse(n.privateKey,ve),i=se.toJSON(s);i.ext=!0,i.key_ops=e[4],i.crv=t.namedCurve,i.kty="EC",e[0]="jwk",e[1]=i}}async fixFirefoxEcExportPkcs8(e){try{if(this.browserInfo.name===fe.Firefox&&"pkcs8"===e[0]&&~["ECDSA","ECDH"].indexOf(e[1].algorithm.name)&&~["P-256","P-384","P-521"].indexOf(e[1].algorithm.namedCurve)){const t=await this.exportKey("jwk",e[1]),r=ie.fromJSON(t,{targetSchema:ve}),n=new le;return n.privateKeyAlgorithm.algorithm=De.ASN_ALGORITHM,n.privateKeyAlgorithm.parameters=te.serialize(new ae(Ie(e[1].algorithm.namedCurve))),n.privateKey=te.serialize(r),te.serialize(n)}}catch(e){return n.error(e),null}}}Qe.methods=["digest","importKey","exportKey","sign","verify","generateKey","encrypt","decrypt","deriveBits","deriveKey","wrapKey","unwrapKey"];class et extends I{constructor(){super(...arguments),this.subtle=new Qe}getRandomValues(e){return i.getRandomValues(e)}}Math.imul||(Math.imul=function(e,t){const r=65535&e,n=65535&t;return r*n+((e>>>16&65535)*n+r*(t>>>16&65535)<<16>>>0)|0});const tt=self;i&&Object.freeze(i.getRandomValues);try{delete self.crypto,tt.crypto=new et,Object.freeze(tt.crypto)}catch(e){n.error(e)}const rt=tt.crypto;return e.crypto=rt,e}({});
//# sourceMappingURL=/sm/2da2f2c78b298351c50a259acc9079f6e373e8d62078554840937e6366f06cea.map

